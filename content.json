{"meta":{"title":"lambert.zxm","subtitle":"I'm","description":"lambert.zxm 的博客 description","author":"lambert.zxm","url":"http://Xminger.github.io","root":"/"},"pages":[],"posts":[{"title":"记录一些常用的配置","slug":"wsSettings","date":"2021-06-09T11:35:01.388Z","updated":"2021-06-09T11:47:49.775Z","comments":true,"path":"2021/06/09/wsSettings/","link":"","permalink":"http://Xminger.github.io/2021/06/09/wsSettings/","excerpt":"","text":"webstorm 重置试用时间webstorm 重置试用时间来自 知了(zhile) webstorm 一些配置 显示空格12settings -&gt; Edit -&gt; Appearance勾选 Show whitespace MAC禁用Adobe Creative Cloud自启状态栏禁用Creative Cloud自启1launchctl unload -w /Library/LaunchAgents/com.adobe.AdobeCreativeCloud.plist 恢复1launchctl load -w /Library/LaunchAgents/com.adobe.AdobeCreativeCloud.plist","categories":[],"tags":[{"name":"setting","slug":"setting","permalink":"http://Xminger.github.io/tags/setting/"}]},{"title":"一些vue的面试题","slug":"vueQ&A","date":"2021-06-09T11:35:01.388Z","updated":"2021-06-09T11:35:01.388Z","comments":true,"path":"2021/06/09/vueQ&A/","link":"","permalink":"http://Xminger.github.io/2021/06/09/vueQ&A/","excerpt":"","text":"1. 对于MVVM的理解 MVVM 是 Model-View-ViewModel 的缩写 Model: * 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为 View: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View ViewModel： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View. 总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 2. 开发中常用的指令有哪些 v-model 一般用在表达输入，很轻松的实现表单控件和数据的双向绑定 v-html 更新元素的 innerHTML v-show 与 v-if 条件渲染, 注意二者区别 使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏 v-on:click 可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数 v-for基于源数据多次渲染元素或模板块 v-bind 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 v-bind:title=”msg”简写：:title=”msg” 3. 详细说下vue的生命周期vue生命周期总共分为8个阶段: 创建前/后，载入前/后，更新前/后， 销毁前/后。 beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化 created (创建后) 完成了 data数据初始化, el还未初始化 beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互 beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 4. Vue的双向数据绑定原理是什么vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体实现步骤，感兴趣的可以看看: 当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果 vue实现数据双向绑定的原理就是用Object.defineproperty()重新定义（set方法）对象设置属性值和（get方法）获取属性值的操纵来实现的。 Object.property()方法的解释：Object.property(参数1，参数2，参数3) 返回值为该对象obj 其中参数1为该对象（obj），参数2为要定义或修改的对象的属性名，参数3为属性描述符，属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合使用。而get和set属于存取描述符对象的属性。 这个方法会直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象。 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"myapp\"&gt; &lt;input v-model=\"message\"/&gt;&lt;br&gt; &lt;span v-bind=\"message\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var model = &#123; message: \"\" &#125;; var models = myapp.querySelectorAll(\"[v-model=message]\"); for (var i = 0; i &lt; models.length; i++) &#123; models[i].onkeyup = function () &#123; model[this.getAttribute(\"v-model\")] = this.value; &#125; &#125; // 观察者模式 / 钩子函数 // defineProperty 来定义一个对象的某个属性 Object.defineProperty(model, \"message\", &#123; set: function (newValue) &#123; var binds = myapp.querySelectorAll(\"[v-bind=message]\"); for (var i = 0; i &lt; binds.length; i++) &#123; binds[i].innerHTML = newValue; &#125; ; var models = myapp.querySelectorAll(\"[v-model=message]\"); for (var i = 0; i &lt; models.length; i++) &#123; models[i].value = newValue; &#125; ; this.value = newValue; &#125;, get: function () &#123; return this.value; &#125; &#125;)&lt;/script&gt; 5. Proxy 相比于 defineProperty 的优势Object.defineProperty() 的问题主要有三个： 不能监听数组的变化 必须遍历对象的每个属性 必须深层遍历嵌套的对象 Proxy 在 ES2015 规范中被正式加入，它有以下几个特点： 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。 除了上述两点之外，Proxy 还拥有以下优势： Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富 Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。 6. vue-router 有哪几种导航守卫? 全局守卫 路由独享守卫 路由组件内的守卫 全局守卫vue-router全局有三个守卫： router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后1234567891011// main.js 入口文件import router from './router'; // 引入路由router.beforeEach((to, from, next) =&gt; &#123; next();&#125;);router.beforeResolve((to, from, next) =&gt; &#123; next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log('afterEach 全局后置钩子');&#125;); 2.路由独享守卫 如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫：123456789101112// main.js 入口文件const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 &#125; &#125; ]&#125;) 路由组件内的守卫 beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建 beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this 7. Vue的路由实现：hash模式 和 history模式 hash模式： 在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash模式下，仅hash符号之前的内容会被包含在请求中，如 http://www.xiaogangzai.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式： history采用HTML5的新特性；且提供了两个新方法：pushState()，replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 history模式下，前端的URL必须和实际向后端发起请求的URL一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。 Vue-Router官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html页面，这个页面就是你 app 依赖的页面。 8. 组件之间的传值通信组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯 父组件给子组件传值 使用props，父组件可以使用props向子组件传递数据。12345678910111213141516171819202122232425262728293031323334// 父组件&lt;template&gt; &lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./child.vue&apos;;export default &#123; components: &#123; child &#125;, data () &#123; return &#123; message: &apos;father message&apos; &#125; &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;&#125;&lt;/script&gt; 子组件向父组件通信 父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件。123456789101112131415161718192021222324252627282930313233343536373839// 父组件&lt;template&gt; &lt;child @msgFunc=&quot;func&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./child.vue&apos;;export default &#123; components: &#123; child &#125;, methods: &#123; func (msg) &#123; console.log(msg); &#125; &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt;点我&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;, methods () &#123; handleClick() &#123; this.$emit(&apos;msgFunc&apos;); &#125; &#125;&#125;&lt;/script&gt; 非父子, 兄弟组件之间通信 vue2中废弃了$dispatch和$broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和12345678910111213141516171819202122232425262728293031323334// bus.jsimport Vue from &apos;vue&apos;export default new Vue()// 兄弟组件一&lt;template&gt; &lt;button @click=&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import Bus from &apos;../common/js/bus.js&apos;export default&#123; methods: &#123; toBus () &#123; Bus.$emit(&apos;on&apos;, &apos;来自兄弟组件&apos;) &#125; &#125;&#125;&lt;/script&gt;// 兄弟组件二&lt;script&gt;import Bus from &apos;../common/js/bus.js&apos;export default &#123; data() &#123; return &#123; message: &apos;&apos; &#125; &#125;, mounted() &#123; Bus.$on(&apos;on&apos;, (msg) =&gt; &#123; this.message = msg &#125;) &#125;&#125;&lt;/script&gt; 9. Vue与Angular以及React的区别？ Vue与AngularJS的区别 Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 AngularJS社区完善, Vue的学习成本较小 Vue与React的区别 vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用； props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图； 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制； 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现； 使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板； 多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法； Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现； react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。 react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。11 .react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin。 10. vuex是什么？怎么使用？哪种功能场景使用它？ vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 Vuex有5种属性: 分别是 state、getter、mutation、action、module; state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters 类似vue的计算属性，主要用来过滤一些数据。 action actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。 使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题。 vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 组件之间全局共享的数据 通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态。 来源： 程序员成长指北","categories":[],"tags":[]},{"title":"前端优化之-Preload 、Prefetch","slug":"preloadAndPrefetch","date":"2021-06-09T11:35:01.387Z","updated":"2021-06-09T11:35:01.387Z","comments":true,"path":"2021/06/09/preloadAndPrefetch/","link":"","permalink":"http://Xminger.github.io/2021/06/09/preloadAndPrefetch/","excerpt":"","text":"起因 今天在帮同事看一个BUG的时候发现了一个奇怪的写法 &lt;link rel=&quot;preload&quot; href=&quot;xxx.js&quot; as=&quot;script&quot;&gt;之前只知道link标签是用来引入样式文件的，这个写法明显是引入js，什么情况？？然后google了一下。 官方说明 元素的 rel 属性的属性值preload能够让你在你的HTML页面中 元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就进行预加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。简单概括：预加载资源 我们将使用preload作为rel属性的属性值。这种做法将把 元素塞入一个预加载器中，这个预加载器也将用于其他我们所需要的，各种各样的，任意类型的资源。为了完成基本的配置，你还需要通过 href和as 属性指定需要被预加载资源的资源路径及其类型。 比如12&lt;link rel=\"preload\" href=\"style.css\" as=\"style\"&gt;&lt;link rel=\"preload\" href=\"main.js\" as=\"script\"&gt; 使用preload好处 使用 as 来指定将要预加载的内容的类型，将使得浏览器能够： 更精确地优化资源加载优先级。 匹配未来的加载需求，在适当的情况下，重复利用同一资源。 为资源应用正确的内容安全策略。 为资源设置正确的 Accept 请求头。 as属性都有那些 audio: 音频文件。 document: 一个将要被嵌入到&lt;frame&gt;或&lt;iframe&gt;内部的HTML文档。 embed: 一个将要被嵌入到&lt;embed&gt;元素内部的资源。 fetch: 那些将要通过fetch和XHR请求来获取的资源，比如一个ArrayBuffer或JSON文件。 font: 字体文件。 image: 图片文件。 object: 一个将会被嵌入到&lt;embed&gt;元素内的文件。 script: JavaScript文件。 style: 样式表。 track: WebVTT文件。 worker: 一个JavaScript的web worker或shared worker。 video: 视频文件。 &lt;link rel=&quot;preload&quot; href=&quot;sintel-short.mp4&quot; as=&quot;video&quot; type=&quot;video/mp4&quot;&gt; 引用MDNw3cplusHelloHello233","categories":[],"tags":[]},{"title":"正则表达式中的特殊字符","slug":"regularExpressions","date":"2021-06-09T11:35:01.387Z","updated":"2021-06-09T11:35:01.387Z","comments":true,"path":"2021/06/09/regularExpressions/","link":"","permalink":"http://Xminger.github.io/2021/06/09/regularExpressions/","excerpt":"","text":"正则表达式中的特殊字符","categories":[],"tags":[{"name":"RegularExpressions","slug":"RegularExpressions","permalink":"http://Xminger.github.io/tags/RegularExpressions/"}]},{"title":"去重排序","slug":"reorder","date":"2021-06-09T11:35:01.387Z","updated":"2021-06-09T11:35:01.387Z","comments":true,"path":"2021/06/09/reorder/","link":"","permalink":"http://Xminger.github.io/2021/06/09/reorder/","excerpt":"","text":"双循环去重 双重for（或while）循环是比较笨拙的方法,它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是O(n^2)，如果数组长度很大，那么将会非常耗费内存1234567891011121314151617181920function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; let res = [arr[0]] for (let i = 1; i &lt; arr.length; i++) &#123; let flag = true for (let j = 0; j &lt; res.length; j++) &#123; if (arr[i] === res[j]) &#123; flag = false; break &#125; &#125; if (flag) &#123; res.push(arr[i]) &#125; &#125; return res&#125; indexOf方法去重1 数组的indexOf()方法可返回某个指定的元素在数组中首次出现的位置。该方法首先定义一个空数组res，然后调用indexOf方法对原来的数组进行遍历判断，如果元素不在res中，则将其push进res中，最后将res返回即可获得去重的数组12345678910111213function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; let res = [] for (let i = 0; i &lt; arr.length; i++) &#123; if (res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]) &#125; &#125; return res&#125; indexOf方法去重2 利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素123456789function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; return Array.prototype.filter.call(arr, function(item, index)&#123; return arr.indexOf(item) === index; &#125;);&#125; 相邻元素去重 这种方法首先调用了数组的排序方法sort()，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束1234567891011121314function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; arr = arr.sort() let res = [] for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] !== arr[i-1]) &#123; res.push(arr[i]) &#125; &#125; return res&#125; 利用对象属性去重 创建空对象，遍历数组，将数组中的值设为对象的属性，并给该属性赋初始值1，每出现一次，对应的属性值增加1，这样，属性值对应的就是该元素出现的次数了1234567891011121314151617function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; let res = [], obj = &#123;&#125; for (let i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; res.push(arr[i]) obj[arr[i]] = 1 &#125; else &#123; obj[arr[i]]++ &#125; &#125; return res&#125; set与解构赋值去重 ES6中新增了数据类型set，set的一个最大的特点就是数据不重复。Set函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重1234567function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; return [...new Set(arr)]&#125; Array.from与set去重 Array.from方法可以将Set结构转换为数组结果，而我们知道set结果是不重复的数据集，因此能够达到去重的目的1234567function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; return Array.from(new Set(arr))&#125;","categories":[],"tags":[]},{"title":"Typescript 基本类型","slug":"ts-basictype","date":"2021-06-09T11:35:01.387Z","updated":"2021-06-09T11:35:01.388Z","comments":true,"path":"2021/06/09/ts-basictype/","link":"","permalink":"http://Xminger.github.io/2021/06/09/ts-basictype/","excerpt":"","text":"布尔值 boolean1let isDone: boolean = false; 数字 number ts支持 10进制 / 16进制 / 2进制 / 8进制 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; 字符串12345678910let name: string = \"bob\";name = \"smith\";let name2: string = 'Jojo';name2 = 'jack';// 模板字符串let name3: string = `Gene`;let age: number = 37;// sentence1和sentence2是一样的let sentence1: string = `Hello, my name is $&#123; name &#125;. I'll be $&#123; age + 1 &#125; years old next month.`;let sentence2: string = \"Hello, my name is \" + name + \".\\n\\n\" + \"I'll be \" + (age + 1) + \" years old next month.\"; 数组 Array123// 定义数组let list: number[] = [1, 2, 3]; // 数字类型的数据let list: Array&lt;number&gt; = [1, 2, 3]; // 数字类型的数据 元组 Tuple 官方描述：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同1234567891011let x = [string, number];x = ['1', 1]; // oky = [1, '1']; // errorconsole.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' 没有 'substr'方法// 当访问一个越界的元素，会使用联合类型（后续会提到）替代：x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 Any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么我们可以使用 any类型来标记这些变量：123456789101112131415let notSure: any = 4;notSure = \"maybe a string instead\"; // oknotSure = false; // ok// 与 Object类型的不同let notSure: any = 4;notSure.ifItExists(); // ok, ifItExists 可能运行的时候存在这个方法let prettySure: Object = 4;prettySure.toFixed(); // Error: '对象'类型上不存在属性'toFixed'。// 当你只知道一部分数据的类型时，any类型也是有用的。let list: any[] = [1, true, \"free\"];list[1] = 100;console.log(list); // [1, 100, \"free\"] Object object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 使用object类型，就可以更好的表示像Object.create这样的API。123456789101112// declare 关键字:// 你可以通过 declare 关键字，来告诉 TypeScript，你正在试图表述一个其他地方已经存在的代码// 一般都是在声明文件里面 定义一些变量 xxx.d.ts eg: declare let process: any;declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Error 枚举 enum enum类型是对JavaScript标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。1234567891011121314151617enum Color &#123;Red, Green, Blue&#125; // 这里是大括号&#123;&#125;let bgColor: Color = Color.Green;// 默认情况下，从0开始为元素编号。// 也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：enum Color &#123;Red = 1, Green, Blue&#125;;let bgColor: Color = Color.Green;// 或者是全部指定enum Color &#123;Red = 1, Green = 3, Blue = 5&#125;;let bgColor: string = Color[3];console.log(bgColor); // 显示'Green'因为上面代码里它的值是3// 枚举类型作用 枚举类型提供的一个便利是你可以由枚举的值得到它的名字 value -&gt; nameenum Color &#123;Red = 1, Green, Blue&#125;let bgColor: string = Color[2];console.log(bgColor); // 显示'Green'因为上面代码里它的值是2 Void 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void;123456function warnUser(): void &#123; console.log(\"This is my warning message\");&#125;// 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：let void1: void = undefined;let void2: void = null; Null 和 Undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大。 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 Never never类型表示的是那些永不存在的值的类型。例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。12345678910111213// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 类型断言 有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 12345678// 类型断言有两种形式。 其一是“尖括号”语法：let someValue: any = \"this is a string\";// let strLength: number = (&lt;string&gt;someValue).length;// as语法let someValue1: any = \"this is a string\";let strLength1: number = (someValue1 as string).length;// 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；// 然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。","categories":[],"tags":[]},{"title":"npm 常用命令","slug":"npmCommand","date":"2021-06-09T11:35:01.386Z","updated":"2021-06-09T11:35:01.386Z","comments":true,"path":"2021/06/09/npmCommand/","link":"","permalink":"http://Xminger.github.io/2021/06/09/npmCommand/","excerpt":"","text":"初始化npm init 查看安装包(每个命令都是，只是展开的方式不一样)npm list npm list -g --depth=0 npm ll npm la npm ls 安装新包npm install packageName npm install -g packageName 更新包npm update packageName 卸载npm uninstall packageName npm uninstall -g packageName 命令npm run xxx (xxx 代表package.json 里面是scripts字段的命令) 清理缓存npm cache clean -f npm源镜像设置淘宝 npm 地址： http://npm.taobao.org/ 百度 npm 地址： http://registry.npm.baidu-int.com/ 1. 临时使用 npm --registry https://registry.npm.taobao.org install xxx 2. 持久使用 npm config set registry https://registry.npm.taobao.org 配置后可通过下面方式来验证是否成功 npm config get registry","categories":[],"tags":[]},{"title":"一些常用的函数","slug":"otherFunction","date":"2021-06-09T11:35:01.386Z","updated":"2021-06-09T11:35:01.386Z","comments":true,"path":"2021/06/09/otherFunction/","link":"","permalink":"http://Xminger.github.io/2021/06/09/otherFunction/","excerpt":"","text":"节流函数 当某个函数被非常频繁地触发，但它期间只少数地几次，限制两次执行的时间间隔不能太短，从而实现性能优化，这样的函数称为节流函数，一般用在窗口缩放、滚动监听等。123456789function throttle(action, wait = 1000) &#123; let time = Date.now(); return function() &#123; if ((time + wait - Date.now()) &lt; 0) &#123; action(); time = Date.now(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"mac 关机、重启、定时关机","slug":"macCommand","date":"2021-06-09T11:35:01.386Z","updated":"2021-06-09T11:35:01.386Z","comments":true,"path":"2021/06/09/macCommand/","link":"","permalink":"http://Xminger.github.io/2021/06/09/macCommand/","excerpt":"","text":"一、关机1sudo halt 1sudo shutdown -h now 二、重启1sudo reboot 1sudo shutdown -r now 三、定时关机 10分钟后关机1sudo shutdown -h +10 晚上8点关机1sudo shutdown -h 20:00 设定时间为2012年7月12日15：00分关机1sudo shutdown -h 1207121500 设定时间为2014年7月11日15：00分重启1sudo shutdown -r 1407111500 四 命令参数 命令：shutdown参数：h/r/s –&gt;分别代表：关机/重启/睡眠。时间：2001011130 2020年1月1号上午11点30分eg: 2020年1月1号上午11点30分关机1sudo shutdown -r 2001011130","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"http://Xminger.github.io/tags/mac/"}]},{"title":"mac 安装mongodb","slug":"installmongodb","date":"2021-06-09T11:35:01.385Z","updated":"2021-06-09T11:35:01.385Z","comments":true,"path":"2021/06/09/installmongodb/","link":"","permalink":"http://Xminger.github.io/2021/06/09/installmongodb/","excerpt":"","text":"一、先去官网下载安装包二、解压三、把解压后的文件剪切到/usr/local文件夹下四、配置环境变量 编辑 ～/.bash_profile把 export PATH=${PATH}:/usr/local/xxx/bin (xxx: 刚才解压的文件夹名字) 复制到最后一行保存，关闭在命令后里面输入source .bash_profile 刷新配置文件 五、验证 在命令后里面输入mongod -version 出现版本号即安装成功 六、设置data路径 新建文件夹然后配置权限 1sudo mkdir -p /data/db &amp;&amp; sudo chmod 0755 /data/db &amp;&amp; sudo chown $USER /data/db 七、启动mongodb 1mongod 在浏览器里面输入localhost:27017显示 1It looks like you are trying to access MongoDB over HTTP on the native driver port. 即启动成功加入提示没有该命令 输入source .bash_profile 刷新配置文件 即可 八、退出 新打开一个命令行输入 12use admin;db.shutdownServer(); 退出成功 其他 还可以通过 Homebrew 安装也可以通过命令安装","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://Xminger.github.io/tags/mongodb/"}]},{"title":"算法相关的JavaScript实现","slug":"jsAlgorithm","date":"2021-06-09T11:35:01.385Z","updated":"2021-06-09T11:35:01.386Z","comments":true,"path":"2021/06/09/jsAlgorithm/","link":"","permalink":"http://Xminger.github.io/2021/06/09/jsAlgorithm/","excerpt":"","text":"计算汉明重量12345678function hammingWeight(n) &#123; let num = 0; while(n !== 0) &#123; n &amp;= (n - 1); num++; &#125; return num; &#125; 判断奇偶123funciton isOdd(n) &#123; return n &amp; 1 === 1; &#125; 二分查找非递归方法123456789101112131415161718function binarySearch(nums, target) &#123; let low = 0; let high = nums.length - 1; while(low &lt;= high) &#123; let mid = parseInt((low + high) / 2); if(nums[mid] === target) &#123; return mid; &#125; if(nums[mid] &gt; target) &#123; high = mid - 1; &#125; if(nums[mid] &lt; target) &#123; low = mid + 1; &#125; &#125; return -1; &#125; 递归方法12345678910111213function binarySearch(nums, target) &#123; let low = 0; let high = nums.length -1; const binaryWalker = (nums, low, high, target) =&gt; &#123; if(low &gt; high) return -1; const mid = parseInt((low + high) / 2); if(nums[mid] === target) return mid; if(nums[mid] &gt; target) return binaryWalker(nums, low, mid - 1, target); if(nums[mid] &lt; target) return binaryWalker(nums, low + 1, high, target); &#125; return binaryWalker(nums, low, high, target); &#125; 常见排序快速排序12345678910111213141516171819function quickSort(arr) &#123; if(arr.length &lt;= 1) return arr; let left = []; let right = []; let pivot = arr[0]; for(let i = 1; i &lt; arr.length; i++) &#123; if(arr[i] &gt;= pivot) &#123; right.push(arr[i]); &#125; else &#123; left.push(arr[i]); &#125; &#125; return [...quickSort(left), pivot, ...quickSort(right)]; &#125; 冒泡排序123456789101112function bubbleSort(arr) &#123; let i = arr.length - 1; while(i &gt;= 0) &#123; for(let j = 0; j &lt; i; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; i--; &#125; return arr;&#125; 二叉树遍历相关先序遍历（中-&gt;左-&gt;右）递归实现1234567function preOrderTraverse(root) &#123; if(root) &#123; console.log(root); preOrderTraverse(root.left); preOrderTraverse(root.right); &#125;&#125; 非递归实现12345678910111213141516function preOrderTraverse(root) &#123; let stack = []; if(root) &#123; stack.push(root); &#125; while(stack.length) &#123; let temp = stack.pop(); console.log(temp); if(temp.right) stack.push(temp.right); if(temp.left) stack.pus(temp.left); &#125;&#125; 中序遍历（左-&gt;中-&gt;右）递归实现1234567function midOrderTraverse(root) &#123; if(root) &#123; midOrderTraverse(root.left); console.log(root); midOrderTraverse(root.right); &#125;&#125; 非递归实现123456789101112131415function midOrderTraverse(root) &#123; let stack = []; while(true) &#123; while(root) &#123; stack.push(root); root = root.left; &#125; if(!stack.length) break; let temp = stack.pop(); console.log(temp); root = temp.right; &#125;&#125; 后序遍历（左-&gt;右-&gt;中）递归实现1234567function postOrderTraverse(root) &#123; if(root) &#123; postOrderTraverse(root.left); postOrderTraverse(root.right); console.log(root); &#125;&#125; 非递归实现123456789101112function postOrderTraverse(root) &#123; let stack = []; let rest = []; if(root)stack.push(root); while(stack.length) &#123; let temp = stack.pop(); rest.push(temp); if(temp.left) stack.push(temp.left); if(temp.right) stack.push(temp.right); &#125; return rest.reverse();&#125; 层次遍历123456789101112function levelTraverse(root) &#123; if(!root) return; let stack = []; stack.push(root); while(stack.length) &#123; let temp = stack.shift(); console.log(temp); if(temp.left) stack.push(temp.left); if(temp.right) stack.push(temp.right); &#125;&#125; 来源：奇舞周刊","categories":[],"tags":[]},{"title":"Hello World","slug":"helloWorld","date":"2021-06-09T11:35:01.385Z","updated":"2021-06-09T11:35:01.385Z","comments":true,"path":"2021/06/09/helloWorld/","link":"","permalink":"http://Xminger.github.io/2021/06/09/helloWorld/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"h5 Android OR Ios 调起键盘","slug":"h5-1","date":"2021-06-09T11:35:01.385Z","updated":"2021-06-09T11:35:01.385Z","comments":true,"path":"2021/06/09/h5-1/","link":"","permalink":"http://Xminger.github.io/2021/06/09/h5-1/","excerpt":"","text":"Android / IOS 监听软键盘弹起和收起12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 判断设备类型let judgeDeviceType = function () &#123; let ua = window.navigator.userAgent.toLocaleLowerCase(); let isIOS = /iphone|ipad|ipod/.test(ua); let isAndroid = /android/.test(ua); return &#123; isIOS: isIOS, isAndroid: isAndroid &#125;&#125;()// 监听输入框的软键盘弹起和收起事件function listenKeybord($input) &#123; if (judgeDeviceType.isIOS) &#123; // IOS 键盘弹起：IOS 和 Android 输入框获取焦点键盘弹起 $input.addEventListener('focus', function () &#123; console.log('IOS 键盘弹起啦！'); // IOS 键盘弹起后操作 &#125;, false) // IOS 键盘收起：IOS 点击输入框以外区域或点击收起按钮，输入框都会失去焦点，键盘会收起， $input.addEventListener('blur', () =&gt; &#123; console.log('IOS 键盘收起啦！'); // IOS 键盘收起后操作 &#125;) &#125; // Andriod 键盘收起：Andriod 键盘弹起或收起页面高度会发生变化，以此为依据获知键盘收起 if (judgeDeviceType.isAndroid) &#123; let originHeight = document.documentElement.clientHeight || document.body.clientHeight; window.addEventListener('resize', function () &#123; let resizeHeight = document.documentElement.clientHeight || document.body.clientHeight; if (originHeight &lt; resizeHeight) &#123; console.log('Android 键盘收起啦！'); // Android 键盘收起后操作 // 修复小米浏览器下，输入框依旧被输入法遮挡问题 if (judgeDeviceType.isMiuiBrowser) &#123; document.body.style.marginBottom = '0px'; &#125; &#125; else &#123; console.log('Android 键盘弹起啦！'); // Android 键盘弹起后操作 // 修复小米浏览器下，输入框依旧被输入法遮挡问题 if (judgeDeviceType.isMiuiBrowser) &#123; document.body.style.marginBottom = '40px'; &#125; &#125; originHeight = resizeHeight; &#125;, false) &#125;&#125;let $inputs = document.querySelectorAll('.input');for (let i = 0; i &lt; $inputs.length; i++) &#123; listenKeybord($inputs[i]);&#125; 弹起软键盘始终让输入框滚动到可视区1234567891011121314// 获取到焦点元素滚动到可视区function activeElementScrollIntoView(activeElement, delay) &#123; let editable = activeElement.getAttribute('contenteditable') // 输入框、textarea或富文本获取焦点后没有将该元素滚动到可视区 if (activeElement.tagName == 'INPUT' || activeElement.tagName == 'TEXTAREA' || editable === '' || editable) &#123; setTimeout(function () &#123; activeElement.scrollIntoView(); &#125;, delay) &#125;&#125;// ---------// Android 键盘弹起后操作activeElementScrollIntoView($input, 1000); 唤起纯数字软键盘12&lt;p&gt;请输入手机号&lt;/p&gt;&lt;input type=\"tel\" novalidate=\"novalidate\" pattern=\"[0-9]*\" class=\"input\"&gt; 如果你在用 IOS12 和 V6.7.4+版本的微信浏览器打开表单输入的 demo ，发现键盘收起后，原本被滚动顶起的页面并没有回到底部位置，导致原来键盘弹起的位置“空”了。1234567891011121314console.log('IOS 键盘收起啦！');// IOS 键盘收起后操作// 微信浏览器版本6.7.4+IOS12会出现键盘收起后，视图被顶上去了没有下来let wechatInfo = window.navigator.userAgent.match(/MicroMessenger\\/([\\d\\.]+)/i);if (!wechatInfo) return;let wechatVersion = wechatInfo[1];let version = (navigator.appVersion).match(/OS (\\d+)_(\\d+)_?(\\d+)?/);if (+wechatVersion.replace(/\\./g, '') &gt;= 674 &amp;&amp; +version[1] &gt;= 12) &#123; setTimeout(function () &#123; window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight)); &#125;)&#125; 键盘弹起后挡住了输入框123console.log('Android 键盘弹起啦！');// Android 键盘弹起后操作activeElementScrollIntoView($input, 1000); 来源：奇舞周刊","categories":[],"tags":[]},{"title":"Git 常用命令","slug":"gitCommand","date":"2021-06-09T11:35:01.384Z","updated":"2021-06-09T11:35:01.384Z","comments":true,"path":"2021/06/09/gitCommand/","link":"","permalink":"http://Xminger.github.io/2021/06/09/gitCommand/","excerpt":"","text":"初始化Git仓库git init 设置本地信息git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; 添加到本地git仓库git add 文件 git commit -m &apos;提交原因&apos; 一次性提交所有改变过的文件git add -A git commit -m &apos;提交原因&apos; 推送到远端仓库git push origin 分支名 版本回退git reset --hard commit_id 或者git reset HEAD^ 查看提交历史git log 或者git log --pretty=oneline 查看状态git status 关联远程库git remote add origin git@server-name:path/repo-name.git 第一次推送master分支git push -u origin master 克隆远端库git clone git@server-name:path/repo-name.git 从远端库拉取当前分支的修改git pull 查看分支git branch 创建分支git branch 分支名 切换分支git checkout 分支名 创建+切换分支git checkout -b 分支名 合并某分支到当前分支git merge 分支名 删除分支git branch -D 分支名 删除远程分支git push origin :分支名 查看分支合并图git log --graph 查看远程库信息git remote -v 创建标签git tag 标签名 可以指定标签信息git tag -a 标签名 -m &quot;信息&quot; 查看所有标签git tag 推送一个本地标签到远程git push origin 标签名 推送全部未推送过的本地标签git push origin --tags 删除一个本地标签git tag -d 标签名 删除一个远程标签git push origin :refs/tags/标签名 设置忽略文件添加.gitignore文件 推荐文章an 廖雪峰的官方网站","categories":[],"tags":[]}]}